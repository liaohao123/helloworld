# C++学习

## 继承

子类继承了父类，子类包含父类时，父类先构造先析构

子类再构造在析构

### 继承同名成员处理方式

子类与父类出现同名成员时，直接访问时访问子类，访问父类中的同名的成员在成员名前加一个父类的作用域，例如s.base::变量名
如果子类出现与父类同名的函数，会自动隐藏父类中的函数，需要加上作用域

### 继承同名的静态成员成员处理方式（static）

##### 通过对象访问

 静态成员类内声明，类外初始化，所有对象共享同一份数据

类外初始化，例如：int base：：m_A=200

同样方位父类中的静态成员要加上作用域 

##### 通过类名访问

例如：cout<<son::m_A<<endl;

通过子类继承的访问父类下的静态成员

例如：cout<<son::base::m_A;

同时函数也可以这样调用

### 多继承语法

语法：class 子类：继承方式：父类，继承方式：父类

不太建议使用多继承

### 菱形继承

#### （一个大类有两个子类，同时这两个子类有同一个子类）virtual来解决这个问题

两个派生类继承同一个类，又有某个类同事继承，叫菱形继承也叫钻石继承

利用虚继承解决菱形继承的问题，加上关键字virtual，虚继承，最大的类叫虚基类

cl /d1 singlecalssXXX "路径"

nullprt空指针

## 多态

### 多态的基本概念

静态多态：函数重载和运算符重载都属于动态重载

动态多态：派生类和虚函数实现运行时多态

##### 静态和动态的区别

静态多态的函数地址早绑定，编译阶段确定函数地址

动态多态的函数地址晚绑定，运行阶段确定函数地址

如果引用的是父类中的同名函数，但是想实现子类中的函数，再父类的同名函数前加上virtual，可实现父类中的函数变成虚函数，同时指针晚绑定可以运行子类中自己的

动态多态的条件：要有继承关系，子类要重写父类中的虚函数，需要父类变成虚函数父类的指针或者引用指向子类函数

例如父类的func函数前面加上virtual这样继承的子类中的同名函数调用时就是子类中的同名函数

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231124231023983.png" alt="image-20231124231023983" style="zoom:150%;" />



vfptr是虚函数的指针，虚函数只会占1的空间，一个指针占4个字节空间

例如一个父类的引用指向一个子类的对象实例，然后调用父类的中的虚函数，此时不会实现父类中的函数，因为指针已经指向了子类中的函数地址，**这是动态实现多态**。子类继承了父类之后，就算就是空类也会有空间，因为汇集成父类中的指针。

### 纯虚函数和抽象类

#### 纯虚函数用法：virtual 返回值类型 函数名 （参数列表） =0

例如：virtual void func（）=0；

当类中有了纯虚函数这个类也变成了抽象类 

**抽象类：无法发实例化对象**

子类必须重写抽象类中的纯虚函数，要不然子类也是抽象类

#### 总结：父类指针指向子类的对象，实现的是子类中重载的虚函数。

### 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父指针在释放时无法调用到子类的析构函数代码

解决方法：将父类中的虚构函数改为**虚析构**和**纯虚析构*

虚析构和纯虚析构的共性：

- 可以解决父类指针释放子类对象
- 都需要具体的函数体现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

 父类指针在指向 子类式，创建在堆区的数据用子类中的析构释放时，不能够完全释放，此时要把父类中的析构编程虚析构才可以释放完父类指针中的数据，在父类析构函数前加上virtual

虚析构和纯虚析构只有一个

纯虚析构virtual~类名 （）=0；

此时在类中只存在声明，不能够直接运行应该在全局区写一个纯虚析构函数的实现内容

**例如animal：：~animal（）{实现内容}**

使用条件总结：前提有继承，而且父类与子类中有同名的重写函数，子类中有 堆区数据，用父类指针new一个子类的数据 

有纯虚析构的类也属于抽象类。

## 文件操作

程序运行是产生的数据都属于临时文件，从程序一旦运行 结束都会被释放

通过**文件可以将数据持久化**

c++中对文件操作需要包含头文件`****<fstream>****`

文件类型分为两种：

1. 文本文件：文件以ASCLL码形式存储在计算机中
2. 二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们

操作文件的三大类

1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作

### 文本文件

### 写文件

步骤：

1. 包含头文件
   **#include<fstream>**
2. 创建流对象
   ofstream ofs
3. 打开文件
   ofs.open（“文件路径”，打开方式）；
4. 写数据
   ofs<<"写入的数据"；ofs相当于cout，cout输出在屏幕，ofs输出屏幕
5. 关闭文件
   ofs.close（）；

文件打开方式：

![image-20231128161503634](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20231128161503634.png)

### 读文件

#### 1.右移方法

1. 包含头文件
   **#include<fstream>**
2. 创建流对象
   ifstream ifs
3. ifs.if_open()是否成果打开文件是一个bool类型返回值的函数
4. 打开文件
   ifs.open（“文件路径”，打开方式）；
5. 写数据
   ifs<<"写入的数据"；ifs中的i是in的意思，意思就是从程序中输入文件中的数据
6. 关闭文件
   ifs.close（）；

in就是从文件中输入进程序中

out就是从程序中输出到文件中

读文件使用循环代码while（ifs >>  buf）

buf是一个数组；要把文件中的数据读进buf这个数组中 来就需要一行一行录入，右移允许算符相当于读取运算符，知道读到最后一个字符变成空的时候才结束进行

#### 2.ifstream.getline（）

同样可以 使用getline函数读取数据getline函数中包含两个数据

例如getline（读取的数组，需要读取的长度），如果需要将数组填满则需要第二个长度与数组大小相同。

#### 3.string buf，使用全局区的getline

使用全局函数下的getline（）函数里面的参数是初始化的ifstream输入流对象

getline（输入流对象，buf），前提初始化一个string类型的对象

#### 4.char 个字符

初始化一个char  C;

while（(C != ifs.get()) != EOF）//EOF是文档尾部，这样也可以读取整个文档内容

### 二进制文件呢ios::binary

创建一下ofstream类型对象

```c++
// *创建一个写二进制的独享*

*void* test06()

{

  ofstream write;

  write.open("*person.txt*", ios::out *|* ios::binary);

  person p = {"*张三*", 18};

  write.write((*const* *char* *)&p, *sizeof*(person));

  write.close();

}

// *读二进制的文件*

*void* test07()

{

  ifstream read;

  read.open("*person.txt*", ios::in *|* ios::binary);

  *if* (!read.is_open())

  {

​    cout *<<* "*打开失败*" *<<* endl;

  }

  person p;

  read.read((*char* *)&p, *sizeof*(p));

  // *读取文件的内容相当于存进初始化的p*

  // *打印输出的时候输出p.name和p.age*

  cout *<<* p.m_Name *<<* p.m_Age *<<* endl;

  //*最后一步关闭文件*

  read.close();

}
```

写入文件（从代码写入到文本文件呢）是out，输出代码中的对象内容到文件中

读取文件（从文本文件读取到代码中） 是in，读取文本文件的内容到代码中的对象中

其中的write函数中包含的应该是常量*数据类型 和数据占有的内存大小

read函数中包含的是数据类型*，和应该 写入数据类型的大小。

